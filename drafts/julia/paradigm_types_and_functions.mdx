# paradigm_types_and_functions

# 类型与函数范式

## 类型与函数范式概论

作为支持多重派发的语言来说，编程解决问题的实质就是去对问题进行拆分，拆分为一个个的类型（其中包含各种各样的数据），然后针对各个类型编写相应的函数。这和主流面向对象语言（如 C++, Python, Java）有点像，但也有不同，在研究范式的时候注意不要与面向对象的写法相混淆。

## 类型

在科学计算中，类型本质上是一个数学对象，这个数学对象对应着某个物理概念，它能与其他的数学对象进行一定的运算。在这个前提下，我们就能理解为什么类型除了构造函数外并不像主流面向对象语言一样含有其他的方法（例如说，实数和实数向量有数乘运算，这个运算不应该属于实数，也不属于实数向量）；我们也能理解相比于类型的成员，我们更关心类型的方法（运算），因而 Julia 不能继承数据结构。一般来讲，我们在平时的学术讨论中高频提到什么概念，我们就应该把什么概念提取出来作为一个类型。例如，一个典型的分子动力学程序可以将系统、传播子和相（原子坐标）写成三个类型 `System, Propagator, Phase`。

### 类型的成员处于同一抽象层级

### 不要把类型成员的类型标注限制得太死

例如，我们可能会想把一个粒子的质量设为 64 位浮点数

```
struct Particle    m::Float64    ...end
```

但这实际上是没必要的。质量只要是个实数，不管实际在计算机上的实现是整数、有理数、16 位 32 位浮点数，都能完成我们需要的运算，所以不如直接设为 `Real` 抽象类型。在使用某些第三方库时（如自动微分），这种设置可能是必需的。

## 函数

函数本质上是数学对象之间的运算，所以函数并不属于某个对象。有些时候一个物理概念既适合作为一个类型也适合作为一个函数（例如算符），这时可以先写类型，然后重载类型的调用（类似于 Python 中的 `__call__` 方法）；当然一元函数很多时候跟乘法没有什么太大的区别（比如说 `H(ψ) = Hψ`），所以也可以写一个乘法来处理这种情况。我比较倾向于第一种。

### 一个函数可以干好几件事，但一个方法只能干一件事

函数应该短小（不超过 20 行，最好不超过 10 行），

- 不要在函数内部判断变量的类型，而是拆分成不同的方法；
- 不要传入一个 `true` 或者 `false` 以在函数内部改变函数的行为，而是拆分成不同的方法；
- 

### 函数的计算处于同一抽象层级

### 克制的参数个数

最好的函数有一个参数（对应于数学上的某种映射），次好的函数有两个参数（对应于数学上的某种运算），如果发现需要三个或者以上的参数就说明代码写得不好。有两种解决方法：

- 把参数变为关键字参数，这适合构造函数等需要传入大量参数的情况；
- 把几个有关联的参数封装为类型。

### 只有很有限的几个函数能访问某个类型的成员

我们更关心类型的行为而不是成员，因此如果一个类型的某个成员在许多函数中都被访问了，说明需要定义新的函数承接对这个成员的访问。

### 只跟熟人打交道

函数不应该调用那些自己定义的用来处理参数以外的值的函数。
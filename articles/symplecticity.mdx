---
title: 分子动力学中的辛算法
date: 2019-08-03
tags: [物理, 化学]
cover: https://cdn.jsdelivr.net/gh/tansongchen/images@master/symplecticity.webp
abstract: 几何视角下的常微分方程数值解
---

# 从一个 naive 的计算机实验说起

## 经典力学方程

在经典力学框架下进行分子动力学模拟，通常首先要考虑经典力学方程的求解问题。众所周知，经典力学有三种**等价的表述方式**：Newton 运动方程、Lagrange 运动方程和 Hamilton 运动方程。设运动自由度数为 *n*，位置为 **q** = (*q*1, …, *qn*)，动量为 **p** = (*p*1, …, *pn*)，他们具体的形式为：

- Newton 形式：

$$
m\frac{\mathrm d^2\mathbf q}{\mathrm dt^2}=-\frac{\partial V}{\partial \mathbf q}
$$ - Lagrange 形式（*L* = *T* − *V*）：

$$
\frac{\mathrm d }{\mathrm d t}\frac{\partial L}{\partial \dot{\mathbf q}}-\frac{\partial L}{\partial \mathbf q}=0
$$ - Hamilton 形式（*H* = *T* + *V*）：

$$
\begin{aligned}
\dot{\mathbf q}&=\frac{\partial H}{\partial \mathbf p}\\
\dot{\mathbf p}&=-\frac{\partial H}{\partial \mathbf q}
\end{aligned}
$$ 尽管它们描述相同的物理，它们的求解方式是不同的。前两个均为广义坐标的二阶常微分方程，而 Hamilton 运动方程（又称「正则方程」，我们下面将使用这个名称）为广义位置和广义动量的一阶常微分方程，它由于**具有突出的对称性**而广泛用于方程的定性分析。

## 谐振子

在使用 Hamilton 动力学求解的系统中，谐振子也许是最简单的一个系统了，它的 Hamilton 量是： $$
H=\frac12p^2+\frac12q^2
$$ 对应的正则方程是： $$
\begin{aligned}
\dot q&=p\\
\dot p&=-q
\end{aligned}
$$ 给定初始条件 *q*(0) = 1, *p*(0) = 0，那么它的解是： $$
\begin{aligned}
q(t)&=\cos t\\
p(t)&=-\sin t
\end{aligned}
$$ 这样的解在二维相空间中描绘一个单位圆轨迹。

![http://ww2.sinaimg.cn/large/006tNc79gy1g55ik7lrfej30hs0gw747.jpg](http://ww2.sinaimg.cn/large/006tNc79gy1g55ik7lrfej30hs0gw747.jpg)

我们现在要问：如果我们不知道解析解的形式，而是采用计算机模拟谐振子的运动来数值求解，那么这样的求解方法将**带来多少误差**？如果我们模拟系统长时间的运动，**误差将下降、不变还是上升**？

## 「更精确」的 Runge-Kutta 算法与「不太精确」的蛙跳算法

不失一般性，我们可以将一阶常微分方程组写成如下的形式[1](about:blank#fn1)： $$
\frac{\mathrm d\mathbf x}{\mathrm d t}=\mathbf f(\mathbf x);\mathbf x(0)=\mathbf x_0
$$ 其中 **x** 是 *n* 个坐标构成的向量，**f** 是 *n* 维的向量函数。当我们数值求解时，我们只能以某个 *Δt* 为时间步长，一步一步计算许多不连续点上的函数值，如 **x**(*Δt*) = **x**1，**x**(2*Δt*) = **x**2，**x**(3*Δt*) = **x**3 等等。

此时误差通常来自于我们对左端的导数项作了一些近似。例如，向前 Euler 算法可以表述为： **x***k* + 1 = **x***k* + **f**(**x***k*)*Δt* 这代表，我们将 **x***k* + 1 和 **x***k* 两个坐标之间的所有变化用一个单一的、**x***k* 处的导数来平均代替了。显然这会带来一定的误差，为了定量衡量这种误差的大小，我们考察坐标的 Taylor 展开： $$
\mathbf x_{k+1}=\mathbf x_k+\dot{\mathbf x}_k\Delta t+\frac12\ddot{\mathbf x}_k\Delta t^2+...
$$ 由于 $\dot{\mathbf x}_k$ 就等于 **f**(**x***k*)，所以向前 Euler 算法与「真正的」解直到 *Δt* 的一次方项都是准确的，而二次方项就不准确了。以上我们引出了**算法阶数**的概念，即：

> 我们称一个算法是 n 阶精度的，如果当时间步长 Δt → 0 时，所求得的解和「真正的」解之间的偏差是 n + 1 阶无穷小量。
>

显然，阶数越高，求解越精确。通过计算更多点的导数值（而不是仅计算一点），我们容易获得具有高阶数的算法，例如 Runge-Kutta 法通过引入了四个近似的导数值，从而具有四阶的精度（请读者自行验证这一点）： $$
\begin{aligned}
\mathbf{a}&=\mathbf{f}\left(\mathbf{x}_{k}\right) \\
\mathbf{b}&=\mathbf{f}\left(\mathbf{x}_{k}+\frac{\Delta t}{2} \mathbf{a}\right) \\ \mathbf{c}&=\mathbf{f}\left(\mathbf{x}_{k}+\frac{\Delta t}{2} \mathbf{b}\right) \\ \mathbf{d}&=\mathbf{f}\left(\mathbf{x}_{k}+\Delta t \mathbf{c}\right) \\
\mathbf{x}_{k+1}&=\mathbf{x}_{k}+\frac{\Delta t}{6}\left(\mathbf{a}+2 \mathbf{b}+2 \mathbf{c}+\mathbf{d}\right)
\end{aligned}
$$

---

现在我们将这种方法应用于谐振子方程的求解中，那么此时 **x** = (*q*, *p*)*T*，**f**(**x**) = (*p*,  − *q*)*T*： $$
\frac{\mathrm d}{\mathrm d t}\begin{pmatrix}
q\\p
\end{pmatrix}=
\begin{pmatrix}
p\\-q
\end{pmatrix}
$$ 只要将它们代入 Runge-Kutta 算法即能进行求解。但在这样做之前，我们再考虑另一种算法，「蛙跳算法」： $$
\begin{aligned}
q_{2k+1}&=q_{2k-1}+2\Delta t\times p_{2k}\\
p_{2k+2}&=p_{2k}-2\Delta t\times q_{2k+1}
\end{aligned}
$$ 蛙跳算法中，我们将 *p* 和 *q* 分别演化，并且一次演化两个时间步长，用中点处的导数近似这段时间内的所有导数。

（读者可能已经明白为什么它叫作「蛙跳算法」了。这种算法的行为就好像是你有一只叫作 *q* 的青蛙和一只叫作 *p* 的青蛙，每只青蛙必须越过另一只青蛙的后背才能向前跳跃，所以青蛙 *q* 经过了每一个奇数号格子，青蛙 *p* 经过了每一个偶数号格子，交替前进。）

读者不妨验证一下，这是只有二阶精度的算法。可以预想到，如果进行求解，当然是四阶精度的 Runge-Kutta 算法好于二阶精度的蛙跳算法。

## 时间尺度与典型性

我们现在取时间步长 *Δt* = 0.1，并对系统演化 1 亿个时间步长。为了考察计算精度，每隔 1 万个时间步长，我们令系统输出一次相空间坐标 (*q*, *p*)*T*[2](about:blank#fn2)：

- 定性考察：把坐标绘制成一张散点图。在没有任何计算误差的情况下，谐振子在相空间做周期运动，这些散点应该落在 *p* + *q* = 1 的单位圆上；

    2

    2

- 定量考察：计算 Hamilton 量的变化值 *H*(*t*) − *H*(0)。在没有任何计算误差的情况下，Hamilton 量应该守恒。

![http://ww4.sinaimg.cn/large/006tNc79gy1g55jd4eicoj30vh0u03zv.jpg](http://ww4.sinaimg.cn/large/006tNc79gy1g55jd4eicoj30vh0u03zv.jpg)

定性考察

令人惊讶的是，计算表明 Runge-Kutta 方法呈现出明显的耗散特性，谐振子在相空间的轨道不断收缩；而蛙跳算法经过 1 亿步之后仍然保持在原有的轨道上。

我们再看定量考察的结果：

![http://ww4.sinaimg.cn/large/006tNc79gy1g55jed243yj30zk0qot8x.jpg](http://ww4.sinaimg.cn/large/006tNc79gy1g55jed243yj30zk0qot8x.jpg)

定量考察

Runge-Kutta 算法的能量在 1 亿步的时间尺度下呈指数衰减，而蛙跳算法没有出现任何衰减的迹象。

那么，Runge-Kutta 作为四阶算法，到底有没有一丁点优势呢？其实还是有的，如果我们只考虑前 100 步而不是 1 亿步演化的话：

![http://ww3.sinaimg.cn/large/006tNc79gy1g55jer4lp2j30zk0qo76h.jpg](http://ww3.sinaimg.cn/large/006tNc79gy1g55jer4lp2j30zk0qo76h.jpg)

前 100 步演化的对比

我们看到，蛙跳算法的 Hamilton 量产生了 1% 左右的振荡，而 Runge-Kutta 方法在短期内非常精确。然而我们已经看到了，这 1% 的振荡没有随着系统的演化而增长。事实上这种振荡是算法的二阶精度所决定的。

综上所述，我们可以对这次 naive 的计算机实验做一个总结：如果我们以这个谐振子的周期 2*π* 作为体系的特征时间，则在与体系特征时间可比拟的时间尺度上（100*Δt* = 10 ∼ 2*π*），高阶的 Runge-Kutta 方法具有明显优势；而在比体系特征时间大几个数量级的时间尺度上，蛙跳算法精确地描绘了谐振子的相空间轨迹，同时保持了长时间的能量守恒。

**对于我们的应用目的而言，分子或原子间作用势对应的特征时间极小，而达到平衡通常不那么迅速。因此，这种在长时间内保持体系良好特性的算法非常重要。**

那么，蛙跳算法为什么具有这样好的性质？它背后是否有更深刻的原理？

# Hamilton 力学的数学结构

## ℝ2*n* 上的辛空间与辛变换

我们现在将具有 1 个自由度的谐振子推广到具有 *n* 个自由度的任意系统。此时，系统的广义位置 **q** 是 *n* 维矢量，广义动量 **p** 是 *n* 维矢量，我们记 $$
\mathbf x=\begin{pmatrix}
\mathbf q\\\mathbf p
\end{pmatrix}
$$ 是 2*n* 维矢量。则 Hamilton 运动方程可以写为： $$
\dot{\mathbf x}=\mathbf S\frac{\partial H}{\partial \mathbf x}
$$ 其中 **S** 是一个反对称的矩阵，我们称之为**单位辛矩阵**： $$
\mathbf S\equiv \begin{pmatrix}
0&I_n\\-I_n&0
\end{pmatrix}
$$ 代入验算，不难验证这种写法与正则方程一致： $$
\mathbf S\frac{\partial H}{\partial \mathbf x}=\begin{pmatrix}
0&I_n\\-I_n&0
\end{pmatrix}\begin{pmatrix}
\frac{\partial H}{\partial \mathbf q}\\\frac{\partial H}{\partial \mathbf p}
\end{pmatrix}=
\begin{pmatrix}
\frac{\partial H}{\partial \mathbf p}\\-\frac{\partial H}{\partial \mathbf q}
\end{pmatrix}=
\begin{pmatrix}
\dot{\mathbf q}\\\dot{\mathbf p}
\end{pmatrix}
$$ 这样我们就称这种写法为**正则方程的标准形**。

---

下面考虑：如果 *f* : ℝ2*n* → ℝ2*n*; **x** → **y** 是一个 ℝ2*n* 上可微的、可逆的变换，那么关于 **y** 的运动方程是： $$
\dot{\mathbf y}=\frac{\partial \mathbf y}{\partial \mathbf x}\dot{\mathbf x}=\frac{\partial \mathbf y}{\partial \mathbf x}\mathbf S\frac{\partial H}{\partial \mathbf x}=\frac{\partial \mathbf y}{\partial \mathbf x}\mathbf S\left(\frac{\partial \mathbf y}{\partial \mathbf x}\right)^T\mathbf S\frac{\partial H}{\partial \mathbf y}
$$ 映射的 Jacobi 矩阵为 $$
\mathbf J=\frac{\partial \mathbf y}{\partial \mathbf x}
$$ 则我们容易得到，变换后的坐标 **y** 仍然满足正则方程的充分必要条件是： **JSJ***T* = **S** 现在，读者（如果还没有忘记线性代数中的线性空间理论）一定会想起实内积空间中由 **JJ***T* = *I* 定义的正交变换、酉空间中由 **JJ**† = *I* 定义的酉变换。而在辛空间中度量矩阵为单位辛矩阵，因此我们自然要称满足上述条件的变换为**辛变换**。

恒等变换是辛变换、辛变换的逆是辛变换、两个辛变换的复合是辛变换。因此，ℝ2*n* 上的全体辛变换 *SP*(2*n*) 连同复合运算一起，构成 2*n* 阶群，我们称之为**辛群**。

## Hamilton 系统的时间演化是辛变换

现在我们要问：辛群有没有一些我们感兴趣的子群？

我们需要回到正则方程的标准形中，鉴于这个方程不显含时间 *t*，它具有时间平移对称性，因此如果我们在 **x**(*t*) 这一相空间轨迹上任意选取两个点，以这两个点为时间原点时体系满足的运动方程是一样的。换句话说，映射 *f* : **x**(*t*1) → **x**(*t*2) **保持正则方程不变，所以它是一个辛变换**。

进而我们知道，给定体系的初始状态 **x**(0)，则体系任一时刻的状态 **x**(*t*) 可以由一个唯一的辛变换作用于初始状态上得到[3](about:blank#fn3)，我们记由时间差 *t* 确定的这个辛变换为 *et*（取演化 evolution 之意），那么所有这样的辛变换构成的子集 {*et*|*t* ∈ ℝ} 对乘法运算封闭（这是因为，对体系先演化 *t*1、再演化 *t*2，和一次性演化 *t*1 + *t*2 是一样的，也即 *et*2*et*1 = *et*1 + *t*2），构成了上面所讨论的辛群的子群，这个子群是单参数的。

## 辛变换与辛算法

上面的讨论表明，如果系统的 Hamilton 量是给定的，那么时间演化算符 *et* 就是确定的，从而正则方程的解可以写成 **x**(*t*) = *et***x**(0) 当然，真正的时间演化算符是无法直接用于计算机中的数值运算的，因此我们要用某些近似的时间演化算符 *Et* 来近似它。这个算符必定满足 *Et* → *et*, *t* → 0 由于这种近似的本性，近似时间演化算符的步长通常取得较小，即用 (*EΔt*)*N* 近似 *eNΔt*。

但是这样的时间演化算符未必是辛的。在《Hamilton 系统的辛几何算法》中，冯康开宗明义地指出：

> 一切 Hamilton 系统的动力演化都保辛度量，即都是辛变换；因此解 Hamilton 方程的「正确」的离散算法就应该是离散辛变换，这样的方法叫做辛算法。
>

因此辛算法的核心思想在于：

> 通过恰当选取迭代格式，使得每一次变换 xk + 1 = EΔtxk 都是辛变换，从而可以保持那些由辛对称性所保证的守恒量。
>

究竟什么是「**由辛对称性所保证的守恒量**」？

### 第一类守恒量

即相空间中的微分形式。在这里由于缺乏微分流形的知识，我们暂时将其统称为「辛结构」，它可以用以下的几何直观描述：

考虑相空间中起始于同一点的两个无穷小向量 *d***x**1, *d***x**2，它们构成一个「二次型」[4](about:blank#fn4) *ω* = (*d***x**1)*T***S***d***x**2 如果一个时间演化 **x** → **y** 是辛变换，那么它对应的 Jacobi 矩阵 **J** 是辛矩阵，那么 (*d***y**1)*T***S***d***y**2 = (*d***x**1)*T***J***T***SJ***d***x**2 = (*d***x**1)*T***S***d***x**2 = *ω* 说明这个「二次型」随时间演化不变。推而广之，任何偶数维「面积」随时间演化不变。当这个维数是 2*n* 时，我们就得到了 Liouville-Poincaré 守恒律：相空间任一体积元随时间演化时其 2*n* 维的体积不变。

### 第二类守恒量

即系统的运动常数，如能量、动量、角动量和 Runge-Lenz 矢量等等。对辛算法而言，通常无法保持它们的严格守恒，但辛算法能保持某种修正后的守恒量，使得计算出的量总是在真实守恒量附近振荡，而不至于有大量的偏移。而这种逼近的阶数与算法本身的阶数相当。

为什么守恒量如此重要？首先值得注意的一点是，作为分子动力学模拟的目标而言，系统相空间的具体轨迹没有那么重要。所有宏观物理量的模拟都是基于大量分子的统计平均，因此个别分子的精确预测对于统计平均没有显著贡献。轨迹在某种意义上也是不可能被准确模拟的，这是因为复杂的多体相互作用将导致常微分方程的 Lyapunov 不稳定性，初始条件的任何微小偏离都将导致轨迹的指数发散。

因此，**守恒量与对称性将成为分子动力学模拟中描述体系规整性的重要语言**。

总而言之，辛算法作为为经典 Hamilton 力学量身订做的算法[5](about:blank#fn5)，在一定程度上也与分子动力学模拟高度契合，大大提高了模拟所能够使用的时间步长，从而在计算资源有限的情况下，能够适用于介观系统的长时间模拟。

# NVE 系综下的辛算法

## 二阶幂零系统与可分系统

鉴于我们以上的讨论，我们平常所使用的最简单的向前 Euler 格式 $$
\mathbf x_{k+1}=\mathbf x_k+\mathbf S\frac{\partial H}{\partial \mathbf x}\bigg |_{\mathbf x_k}
$$ 一般不是辛的。但是，有没有可能对于某些特殊的 Hamilton 量，这种格式是辛的呢？我们先考虑只含动量的 Hamilton 量 *H*(**p**)，并试图求相空间坐标的二阶导数： $$
\ddot{\mathbf x}=\frac{\mathrm d }{\mathrm d t}\dot{\mathbf x}=\frac{\mathrm d}{\mathrm d t}\mathbf S\frac{\partial H}{\partial \mathbf x}=\mathbf S\frac{\partial^2 H}{\partial \mathbf x\partial \mathbf x}\mathbf S\frac{\partial H}{\partial \mathbf x}
$$ 读者可以自行验算右端为 0，我们定义这样的系统为**二阶幂零系统**。对上式的一个简单（但不严格）的物理解释是，Hamilton 量不含势能项意味着粒子自由运动，动量守恒，动量的导数为 0；位置的二阶导数是速度的一阶导数，所以也为 0。同理，由于 Hamilton 力学中位置和动量是可以交换的，对于形如 *H*(**q**) 的 Hamilton 量，相空间坐标的二阶导数也总是为 0。

这意味着，虽然向前 Euler 格式只有一阶精度，但对特定的系统，坐标所有二阶以上的导数全部为 0，因此向前 Euler 格式所产生的轨迹就是系统的真实轨迹！系统的真实轨迹对应的离散变换当然是辛的，因此**向前 Euler 格式在这种 Hamilton 量下是辛的**。这种看法具有重要的应用。

---

出于我们的实用目的，我们接下来将仅仅讨论这样的系统： *H* = *V*(**q**) + *T*(**p**) 也即势能仅仅与位置有关，动能仅仅与动量有关，我们称之为**可分系统**。尽管我们可以在理论力学课本中找到各种各样奇奇怪怪的 Hamilton 量不符合这种划分，在实际的分子模拟中这样的条件却是常常满足的。对于这样的系统来说，如果进行动能项诱导的向前 Euler 格式演化（此时只有坐标发生了变化）： $$
\mathbf q_{1}=\mathbf q_0+\frac{\partial T}{\partial \mathbf p}\bigg |_{\mathbf p_0}\Delta t;\mathbf p_1=\mathbf p_0
$$ 那么它可以视为一个只含动能项的 Hamilton 量所产生的真实演化，所以这个变换是辛的。同理， $$
\mathbf p_{2}=\mathbf p_{1}-\frac{\partial V}{\partial \mathbf q}\bigg |_{\mathbf q_{1}}\Delta t;\mathbf q_2=\mathbf q_1
$$ 也是辛的。辛变换的乘积是辛变换，我们记第一个变换为 *eΔtT*，第二个变换为 *eΔtV* （虽然它们是差分格式，但也恰好是子系统的真实演化算符，所以用小写 *e*，但显然它们相继变换不是整个系统的真实演化算符，所以用大写 *E*），则 *EΔt* = *eΔtVeΔtT* 也是一个辛变换。特别地，出于简洁考虑，我们作以下标记： $$
\frac{\partial T}{\partial \mathbf p}\bigg |_{\mathbf p_n}=\mathbf G(\mathbf p_n);-\frac{\partial V}{\partial \mathbf q}\bigg |_{\mathbf q_{n}}=\mathbf F(\mathbf q_n)
$$ 其中 *Gi* 是相应于广义位置 *qi* 的速度，*Fi* 是相应于广义位置 *qi* 的力。

## 可分系统任意阶数的辛算法

现在的问题是：*EΔt* 虽然是辛变换，但它与系统的真实演化 *eΔt* 是什么关系呢？我们接下来说明，*EΔt* 是一种一阶辛算法。这是因为： $$
\begin{aligned}
\mathbf q_{2}&=\mathbf q_1=\mathbf q_0+\mathbf G(\mathbf p_0)\Delta t
\\
\mathbf p_{2}&=\mathbf p_1+\mathbf F(\mathbf q_1)\Delta t=\mathbf p_0+\mathbf F(\mathbf q_1)\Delta t
\end{aligned}
$$ 我们将后一项再（围绕 **x**0）作一次 Taylor 展开，就得到： $$
\mathbf p_0+\mathbf F(\mathbf q_1)\Delta t=\mathbf p_0+\mathbf F(\mathbf q_0)\Delta t+\frac{\partial \mathbf F}{\partial \mathbf q}\bigg|_{\mathbf q_0}\mathbf G(\mathbf p_0)\Delta t^2+O(\Delta t^3)
$$ 而系统的真实演化是什么呢？它可以由 Taylor 展开给出： $$
\begin{aligned}
\mathbf q&=\mathbf q_0+\mathbf G(\mathbf p_0)\Delta t+\frac12\frac{\partial \mathbf G}{\partial \mathbf p}\bigg|_{\mathbf p_0}\mathbf F(\mathbf q_0)\Delta t^2+O(\Delta t^3)\\
\mathbf p&=\mathbf p_0+\mathbf F(\mathbf q_0)\Delta t+\frac12\frac{\partial \mathbf F}{\partial \mathbf q}\bigg|_{\mathbf q_0}\mathbf G(\mathbf p_0)\Delta t^2+O(\Delta t^3)
\end{aligned}
$$ 因此，这种算法与系统的真实运动直到 *Δt* 的一次项都相同，当然是一种一阶辛算法。

---

我们希望用类似的方法构建更高阶数的辛算法。为此，我们考察在可分系统的框架下，对 Hamilton 量的最一般的划分方式： *H* = *a*1*T* + *b*1*V* + *a*2*T* + ... + *bnV* + *an* + 1*T* 这些划分满足 *a*1 + … + *an* + 1 = 1，并且 *b*1 + … + *bn* = 1。类似的，我们可以说明 *EΔt* = *eΔtan* + 1*TeΔtbnV*...*eΔta*1*T* 是一个辛变换。现在我们的任务就在于，通过适当地调整这 2*n* + 1 个系数（在总和为 1 的限制下，有 2*n* − 1 自由度），使得它具有任意高的阶数。

实际上，辛算法的可能性远远不止如上框架中的设计方案，但对于可分系统而言，很难找到比如上方案更加简洁自然的辛算法实现方式。因此目前几乎所有在分子模拟中应用辛算法的实践都是基于这种方法的。

## 可分二阶辛算法、蛙跳算法与 Verlet 算法

我们现在试图构造一个二阶的算法。刚才我们用两步演化实现了一阶精度，我们考虑能不能在上面的划分方式中取 *n* = 1，用三步演化实现两阶精度呢？我们写出三步演化之后的坐标，其中第一步只演化位置，第二步只演化动量，第三步只演化位置： $$
\begin{aligned}
\mathbf q_{3}&=\mathbf q_0+a_2\mathbf G(\mathbf p_2)\Delta t+a_1\mathbf G(\mathbf p_0)\Delta t
\\
\mathbf p_{3}&=\mathbf p_0+b_1\mathbf F(\mathbf q_1)\Delta t
\end{aligned}
$$ 其中 *a*1 + *a*2 = 1 并且 *b*1 = 1。现在我们还有一个自由参数 *a*1 没有确定。我们仍作上述 Taylor 展开： $$
\begin{aligned}
\mathbf q_{3}&=\mathbf q_0+a_2\mathbf G(\mathbf p_0)\Delta t+a_1\mathbf G(\mathbf p_0)\Delta t+a_2\frac{\partial \mathbf G}{\partial \mathbf p}\bigg|_{\mathbf p_0}\mathbf F(\mathbf q_0)\Delta t^2+O(\Delta t^3)
\\
\mathbf p_{3}&=\mathbf p_0+b_1\mathbf F(\mathbf q_0)\Delta t+a_1\frac{\partial \mathbf F}{\partial \mathbf q}\bigg|_{\mathbf q_0}\mathbf G(\mathbf p_0)\Delta t^2+O(\Delta t^3)
\end{aligned}
$$ 容易看出来，只要取 *a*1 = *a*2 = 0.5，*b*2 = 1 就可以与真实轨迹直到前两阶都符合。

---

现在我们再进行一些小小的改动。注意到 **p**2 = **p**3，**p**3 是下一轮循环中的 **p**0，所以第三步演化位置所用的那个动量就是下一轮循环中第一步演化位置所用的那个动量。因此在连续操作中我们完全可以将两步合起来，也即（省去了相等坐标的重复标号）： $$
\begin{aligned}
\mathbf q_1&=\mathbf q_0+\mathbf G(\mathbf p_0)\Delta t/2\\
\mathbf p_1&=\mathbf p_0+\mathbf F(\mathbf q_1)\Delta t\\
\mathbf q_2&=\mathbf q_1+\mathbf G(\mathbf p_1)\Delta t\\
\mathbf p_2&=\mathbf p_1+\mathbf F(\mathbf q_2)\Delta t\\
&...
\end{aligned}
$$ 此时，如果我们将第一个式子中的 *Δt*/2 看作是「半个时间步长」，那么我们就得到了这样一幅图像：所有位置都在半整数时间步长处更新，所有动量都在整数时间步长更新，更新位置所用的动量恰好在老位置和新位置之间，更新动量时也是如此。

**有没有觉得这个图像很熟悉？？？**

没错，这就是我们此前使用过的蛙跳算法！现在我们可以对蛙跳算法在计算机实验中的优越表现作出解释：

> 蛙跳算法所产生的轨迹完全等价于一个可分系统的二阶辛算法。Hamilton 量是这个可分系统相空间坐标的二次型，因此有一个修正的 Hamilton 量是守恒量，这个修正的 Hamilton 量与真正的 Hamilton 量的误差是二阶的，因此真正的 Hamilton 量总是在某一数值上下波动而不会有大的偏差。
>

---

以上是我们使用 Hamilton 力学分析得到的结果。而在分子动力学模拟中，出于计算效率的考虑，有时我们会使用一些 Newton 力学中的物理量进行实际计算。现在我们将蛙跳算法改写为 Newton 力学形式： $$
\begin{aligned}
\mathbf q(t+\Delta t)&=\mathbf q(t-\Delta t)+\mathbf v(t)\times 2\Delta t\\
\mathbf v(t+2\Delta t)&=\mathbf v(t)+\frac{\mathbf F(\mathbf q(t+\Delta t))}m\times 2\Delta t
\end{aligned}
$$ 这里我们将动能 *T* = **p***T***p**/2*m* 的实际表达式代进去，则 **q** 就是直角坐标，**v** 就是通常意义下的速度，第一个方程用速度更新位置，第二个方程用力（也就是加速度）更新速度。

在 Newton 力学中，速度是位置求导数得到的，并不像 Hamilton 力学中广义动量与广义位置有同等的地位。因此，我们试着在上式中把速度消掉，只留下位置，为此我们考虑 **q**(*t* + 3*Δt*) 的表达式： $$
\begin{aligned}
\mathbf q(t+3\Delta t)&=\mathbf q(t+\Delta t)+\mathbf v(t+2\Delta t)\times 2\Delta t\\
&=\mathbf q(t+\Delta t)+\left[\mathbf v(t)+\frac{\mathbf F(\mathbf q(t+\Delta t))}m\times 2\Delta t\right]\times 2\Delta t
\\
&=\mathbf q(t+\Delta t)+\mathbf v(t)\times 2\Delta t+\frac{\mathbf F(\mathbf q(t+\Delta t))}m\times 4\Delta t^2
\\
&=2\mathbf q(t+\Delta t)-\mathbf q(t-\Delta t)+\frac{\mathbf F(\mathbf q(t+\Delta t))}m\times 4\Delta t^2
\end{aligned}
$$ 我们先将 **v**(*t* + 2*Δt*) 用 **v**(*t*) 代换掉，再用上一次迭代的位置将 **v**(*t*) 也代换掉，就得到了只包含位置的方程。在计算时，我们可以完全不计算速度，大大节省了时间。这被称为 Verlet 算法。

## 高阶算法及关于实用性的讨论

同理，可以推导三阶及以上的算法。（事实上笔者刚才试着推了一下三阶的算法然后放弃了。）给定足够大的 *n*，任意阶数的精度都可以得到满足。但一个不利的地方在于，阶数增高之后对于 *n* 的要求极大。例如，尽管 *n* = 1 可以得到二阶精度算法，但 *n* = 3 才能得到三阶和四阶精度算法，*n* = 8 才能得到六阶精度算法，*n* = 16 才能得到八阶精度算法。注意有些时候在确定 *n* 时会有冗余的自由度，这时通常可以以「守恒量的守恒程度」作为标准将冗余的自由度也用于改进算法。出于这样的原因，对于同一阶数的算法也许不是 *n* 越小越好。

在给定精度要求下，究竟是使用较小的步长和较低的阶数比较好，还是使用较大的步长和较高的阶数比较好？这通常没有一般的答案。有研究表明，*n* = 4 的四阶算法对大多数体系比较适用，而阶数更高时对精度没有太大提升。

# NVT 系综下的辛算法

## Nosé-Poincaré Hamilton 量

刚才我们讨论了系统粒子数、体积、能量固定的情况，这是 Hamilton 力学所固有的特性（当 Hamilton 量不含时时）。在统计力学的视角看来，这对应着微正则系综（NVE 系综），当我们模拟大量粒子并达到平衡后，对粒子的统计平均即是微正则系综平均。

然而，辛算法也可以用于其他系综，例如正则系综（NVT 系综），这通常是通过扩展 Hamilton 量来完成的。例如，我们定义 *N* + 1 个自由度的 Hamilton 量*H̃*(**q**, **p**, *s*, *π*)，*s* 是第 *N* + 1 个「位置」，而 *π* 是共轭于这个位置的「动量」。如果这个扩展 Hamilton 量对应的微正则系综分布函数正比于原 Hamilton 量的正则系综配分函数，即 ∫*d***q***d***p***dsdπδ*(*H̃*(**q**, **p**, *s*, *π*) − *E*) = *C*(*β*, *E*) × ∫*d***q***d***p**exp [−*βH*(**q**, **p**)] 那么显然，对 *N* + 1 个自由度的 NVE 系综模拟等价于对 *N* 个自由度的 NVT 系综模拟。1991 年 Laird 等人找到了这样的一种扩展的 Hamilton 量[6](about:blank#fn6)，它表示为（其中 *H*0 是初始时刻的 Hamilton 量： $$
\tilde H(\mathbf q, \mathbf p, s,\pi)=s\left[\frac1{s^2}T(\mathbf p)+V(\mathbf{q})+\frac{\pi^{2}}{2 Q}+g k T \ln s-H_{0}\right]
$$

运用这种 Hamilton 量生成正则系综分布的方法就叫 Nosé-Poincaré 控温方法。下面我们针对这样的系统构造辛算法。但不幸的是，由于 *s* 也是位置，这个系统的动能和势能不是分离的，我们此前关于可分系统的讨论在这里不适用。不过，对于任何 Hamilton 量的分解，以下关系都是成立的： $$
\begin{aligned}
\tilde H=\sum_{i=1}^mH_i\Rightarrow e_{\Delta t}^{H_m}...e_{\Delta t}^{H_1}\in \mathrm{SP}(2n)
\end{aligned}
$$ 这里 *eΔtHi* 表示以 *Hi* 为系统 Hamilton 量时系统的真实演化算符。也就是说，不管 Hamilton 量长什么样子，只要我们能将它分解并依次在这些「子」Hamilton 量下演化，整体的演化算符就是辛的。这是因为：Hamilton 正则方程保辛结构与 Hamilton 量的具体形式无关，因此 *Hi* 也可以视为某个系统的 Hamilton 量（虽然它不对应着物理真实），所以每个 *eΔtHi* 都是辛的，它们的乘积也是辛的。

如果是这样的话，我们在上一节为什么要求子 Hamilton 量是二阶幂零的呢？这是因为，二阶幂零的 Hamilton 量的方程特别容易求解，因为相空间坐标的所有二阶以上导数均为 0，即 $$
\dot{\mathbf x}=C\Rightarrow \mathbf x(t)=\mathbf x_0+C t
$$ 我们先来考虑一种比较广泛的二阶幂零系统的情况，即对于每对共轭的广义位置和动量，子 Hamilton 量只含其中的一个。不失一般地，子 Hamilton 量写作： *h* = *h*(*p*1, ..., *pk*, *qk* + 1, ..., *qN*) 它的演化方程是： $$
\begin{aligned}
\dot q_i=\frac{\partial h}{\partial p_i}\quad &i=1,...,k\\
\dot q_i=\frac{\partial h}{\partial p_i}=0\quad &i=k+1,...,N\\
\dot p_i=-\frac{\partial h}{\partial q_i}=0\quad &i=1,...,k\\
\dot p_i=-\frac{\partial h}{\partial q_i}\quad &i=k+1,...,N\\
\end{aligned}
$$ 上式第二和第三个方程意味着，*p*1, …, *pk*; *qk* + 1, …, *qN* 在演化中全部不变！这些坐标恰好是 *h* 的全部变量，因此 *h* 关于它们的导数也是全部不变的，因此所有坐标的二阶导数均为 0，可以轻易解出 **x**(*t*) = **x**0 + *Ct*。读者也可以用正则方程的标准形通过矩阵运算得出这个结论。

## Nosé-Poincaré 差分格式的构建

但是当子 Hamilton 量不是二阶幂零的时候，并不意味着这个方程我们解不了；特别是只涉及一对共轭相空间坐标的时候，很多情况下可以转化为简单的常微分方程组求解。例如，我们将上面的 Nosé-Poincaré Hamilton 量拆分成： $$
\begin{aligned}
H_1&=s\left[\frac1{s^2}T(\mathbf p)+g k T \ln s-H_{0}\right]\\
H_2&=sV(\mathbf{q})\\
H_3&=\frac{s\pi^2}{2Q}
\end{aligned}
$$ 可以看到，*H*1 只含第 1 至 N 个动量和第 *N* + 1 个位置；*H*2 只含位置；只有 *H*3 是需要特殊处理的，而好在它只含一对共轭变量。*H*3 对应的正则方程是： $$
\begin{aligned}
\dot s&=\frac{\partial H_3}{\partial \pi}=\frac{s\pi}{Q}\\
\dot \pi&=-\frac{\partial H_3}{\partial s}=-\frac{\pi^2}{2Q}
\end{aligned}
$$ 第二个方程是只含一个变量的常微分方程，可以用分离变量法求解： $$
\pi(t)=\left[\frac{t}{2Q}+\frac1{\pi(0)}\right]^{-1}
$$ 再代入第一个方程，它是标准的一阶线性齐次方程，求解得到： $$
s(t)=s(0)\exp\left[\int_0^t\frac{\pi(t)}Q\mathrm dt\right]=s(0)\left(\frac{\pi(0)t+2Q}{2Q}\right)^2
$$ 因此，这三个真实演化算符的形式是完全清楚的，所以以下算法必然是有一阶精度的辛算法： **x***k* + 1 = *eΔtH*3*eΔtH*2*eΔtH*1**x***k* 不过，文献中[^be]实际用的是这样的辛算法，如同可分系统的蛙跳算法一样，读者可以验证它有二阶精度： **x***k* + 1 = *eΔtH*3/2*eΔtH*2/2*eΔtH*1*eΔtH*2/2*eΔtH*3/2**x***k*

## 时间反演对称性

下面我们讨论一下这两个格式的差别。除去精度提高一阶之外，二阶算法还有一个有趣的特性：时间反演对称。对于系统的真实动力学演化而言，满足的方程总是时间反演对称的（存在外磁场时，可能例外），而差分格式通常不是时间反演对称的。我们称一个差分格式是时间反演对称的，如果： **x***k* + 1 = *EΔt***x***k* ⇒ **x***k* = *E* − *Δt***x***k* + 1 很明显，刚才的二阶算法中，几个子系统的演化算符正过来写和倒过来写都一样，所以它是时间反演对称的；而一阶算法的时间反演将是 **x***k* = *e* − *ΔtH*1*e* − *ΔtH*2*e* − *ΔtH*3**x***k* + 1，这是不对称的。

但比较微妙的是，时间反演对称性与此前讨论过的对称性区别在于，时间反演对称性并不对应着什么守恒量，因此一个时间反演对称的算法很难说给我们带来了什么具体的好处。不过，这就像 Liouville-Poincaré 守恒律一样，一个高维的面积守恒没有什么真实的物理意义，我们大概只能相信这种对称性使系统变得更加「规整」，更加贴近客观事实，或者更玄妙一点说，「对称是美的」。

# 总结

## Hamilton 系统辛几何算法的一般流程

综上所述，当我们利用辛几何方法在给定系综下研究 Hamilton 系统的分子动力学时，它的一般流程就是：

根据系统的 Hamilton 量 *H* 构造合理的扩展 Hamilton 量 *H*′，使得 *H*′ 生成的微正则系综配分函数正比于 *H* 生成的给定系综的配分函数；将 *H*′ 拆分为一些子 Hamilton 量 *Hi* 之和，使得每一个 *Hi* 对应的时间演化算符 *ei* 易于解析求解，且这些算符都对应着辛变换；将子 Hamilton 量继续拆分并排列为辛差分格式 *E*，分析它对体系真实时间演化算符 *e* 的逼近阶数；如果系统具有时间反演对称性，在构造辛算法时还需要尽量满足这一对称性；分析系统的二次型守恒量，对于那些在辛差分格式中不精确守恒的力学量（特别是 *H*′）计算修正后的守恒量并分析逼近阶数。

当然，在这里值得再次提醒，辛几何算法内涵丰富，其差分格式的构造并不限于如上所述的拆分方法。对于具体系统而言，其他的构造方式有可能得到更为高效的差分格式。

## 展望：非 Hamilton 系统的几何算法

尽管辛算法内涵丰富、应用广泛，但在分子动力学模拟中还是常常遇到非 Hamilton 系统，例如：

- Nosé-Hoover 控温方法。尽管这种方法相较 Nosé-Poincaré 方法更加简洁，但其生成的正则系综分布是关于标度后的动量 *p*/*s* 的分布，其中的标度变换不是正则变换，所以生成正则系综分布的过程中运动方程失去了正则性（请注意系综的「正则」和 Hamilton 力学的「正则」不是一个意思）。

    *i*

- Langevin 动力学。Langevin 方程模拟粒子在一定温度下的 Brownian 运动，其平衡均方速度受温度控制，因而也成为一种有效的控温方案，但这种随机性显然与确定性的 Hamilton 力学格格不入。

对于这样的系统，能否通过分析其对称性找到类似的几何算法，从而增强模拟的准确性？这是一个值得探索的问题。

---

1. 该形式右端函数不含自变量 *t*，有时我们称这类方程是「自治的」或者「驻定的」。对于我们讨论的（不含时的）Hamilton 量来说，这一条件自然满足。[↩](about:blank#fnref1)
2. 细心的读者可能已经注意到了，蛙跳算法的位置只在奇数时刻被计算，动量只在偶数时刻被计算，无法得到同一时刻的相空间坐标。所以这里我们用 *q*2*k* ≈ (*q*2*k* + 1 + *q*2*k* − 1)/2 近似计算偶数时间的位置，同理计算奇数时间的动量。[↩](about:blank#fnref2)
3. Hamilton 力学中，通过相空间一点的轨迹唯一。这也是下面「对乘法运算封闭」论述的关键。[↩](about:blank#fnref3)
4. 其实就是外微分形式中的一个闭 2-形式。[↩](about:blank#fnref4)
5. 在冯康《Hamilton 系统的辛几何算法》中，实际也讨论了量子系统作为无穷维 Hamilton 系统的几何解法。但本文中将只考虑经典系统。[↩](about:blank#fnref5)
6. S. D. Bond, B. J. Leimkuler and B. B. Laird: *J. Comp. Phys.* 151 (1999) 114.[↩](about:blank#fnref6)
